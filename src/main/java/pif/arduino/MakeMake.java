package pif.arduino;

import java.io.*;

import org.apache.log4j.Logger;
import org.apache.commons.cli.*;

import pif.arduino.tools.ArduinoConfig;
import pif.arduino.tools.LoadConfig;
import processing.app.BaseNoGui;
import processing.app.debug.TargetBoard;
import processing.app.debug.TargetPlatform;
import processing.app.helpers.PreferencesMap;
import processing.app.helpers.StringReplacer;

public class MakeMake {
	private static Logger logger = Logger.getLogger(MakeMake.class);

	static Options options;
	static {
		options = new Options();
		options.addOption("h", "help", false, "usage");
		options.addOption("I", "arduino-ide", true, "base installation directory of Arduino IDE");
		options.addOption(LoadConfig.PREFERENCES_OPTION, false, "alternate Arduino IDE preferences file");
		OptionGroup choice =  new OptionGroup();
		choice.addOption(new Option("b", "board", true, "target board name"));
		choice.addOption(new Option("B", "boards", false, "list available boards"));
		choice.setRequired(true);
		options.addOptionGroup(choice);
		options.addOption("o", "output", true, "output directory for generated files");
	}

	public static void main(String[] args) {
		// -- mandatory option(s)
		CommandLine commandLine = null;
		try {
			commandLine = new BasicParser().parse(options, args);
		} catch (ParseException e) {
			logger.error(e);
			usage(1);
		}
		if (commandLine.hasOption('h')) {
			usage(0);
		}

		if (!LoadConfig.load(commandLine)) {
			usage(2);
		}

		if (commandLine.hasOption('B')) {
			ArduinoConfig.listBoards(System.out, false, false);
		} else {
			generateBoard(
					commandLine.getOptionValue('b'), // board
					commandLine.getOptionValue('o'));// output directory
		}
	}

	public static String makefileName(String boardName) {
		return "Makefile.target." + boardName;
	}

	protected static void generateBoard(String boardName, String outdir) {
		TargetBoard board = ArduinoConfig.setBoard(boardName);
		if (board == null) {
			usage(3);
		}
		TargetPlatform pf = board.getContainerPlatform();
		logger.info(String.format("found board %s:%s:%s", pf.getContainerPackage().getId(), pf.getId(), board.getId()));

		File outFile = new File(outdir == null ? "." : outdir);
		if (outFile.isDirectory()) {
			outFile = new File(outFile, makefileName(boardName));
		} else if (!outFile.getParentFile().isDirectory()) {
			logger.fatal("outdir must be an existing directory or a file name in existing directory");
			System.exit(4);
		}
		PrintWriter out = null;
		try {
			out = new PrintWriter(outFile);
		} catch (FileNotFoundException e) {
			logger.fatal("Can't open output file", e);
			System.exit(4);
		}

//		SketchData sketch = new SketchData(new File("toto.cpp"));
		PreferencesMap prefs;
		try {
			// arguments are unused, we must just instantiate Compiler class to access to preferences
			processing.app.debug.Compiler compiler = new processing.app.debug.Compiler(null, "${TARGET_DIR}", "${PROJECT_NAME}");
			prefs = compiler.getBuildPreferences();
		} catch (Exception e) {
			e.printStackTrace();
			return;
		}
		prefs.put("ide_version", "" + BaseNoGui.REVISION);
		ArduinoConfig.changePathSeparators(prefs);
//		logger.debug("prefs = " + prefs);

		logger.debug("generating board file");
		out.println("## autogenerated makefile rules for package %s, platform %s, board %s");

		out.println("\n## generate code from c, cpp, ino or S files");
		out.println("${TARGET_DIR}/%.o: %.c");
		out.println("\t@${MKDIR} ${TARGET_DIR}/${*D}");
		out.println("\t" + processRecipe(prefs, "recipe.c.o.pattern",
				"runtime.ide.path", "${ARDUINO_IDE}",
				"includes", "${INCLUDE_FLAGS}",
				"+compiler.c.extra_flags", "${CFLAGS}",
				"source_file", "$<",
				"object_file", "${TARGET_DIR}/$*.o"));
		out.println("${TARGET_DIR}/%.o: %.ino");
		out.println("\t@${MKDIR} ${TARGET_DIR}/${*D}");
		out.println("\t" + processRecipe(prefs, "recipe.cpp.o.pattern",
				"runtime.ide.path", "${ARDUINO_IDE}",
				"includes", "${INCLUDE_FLAGS}",
				"+compiler.cpp.extra_flags", "${CXXFLAGS} -x c++",
				"source_file", "$<",
				"object_file", "${TARGET_DIR}/$*.o"));
		out.println("${TARGET_DIR}/%.o: %.cpp");
		out.println("\t@${MKDIR} ${TARGET_DIR}/${*D}");
		out.println("\t" + processRecipe(prefs, "recipe.cpp.o.pattern",
				"runtime.ide.path", "${ARDUINO_IDE}",
				"includes", "${INCLUDE_FLAGS}",
				"+compiler.cpp.extra_flags", "${CXXFLAGS}",
				"source_file", "$<",
				"object_file", "${TARGET_DIR}/$*.o"));
		out.println("${TARGET_DIR}/%.o: %.S");
		out.println("\t@${MKDIR} ${TARGET_DIR}/${*D}");
		String recipe = processRecipe(prefs, "recipe.S.o.pattern",
				"runtime.ide.path", "${ARDUINO_IDE}",
				"includes", "${INCLUDE_FLAGS}",
				"+compiler.S.extra_flags", "${SFLAGS}",
				"source_file", "$<",
				"object_file", "${TARGET_DIR}/$*.o");
		if (recipe == null) {
			out.println("\t$(error No rule to compile this kind of file for this target platform)");
		} else {
			out.println("\t" + recipe);
		}

		// Preferences recipes contains explicitly {build.path}/{target file} rules
		// thus we can't generate rules where destination is just $*
		// => Have to prefix rules with ${TARGET_DIR} (which is specified as build path)
		// as recipe puts quotes around "object_file" entry, we have to  put only first file in it and append
		// other ones after command
		out.println("\n## generate lib from .o files");
		out.println("${TARGET_DIR}/%.a: ${OBJS}");
		out.println("\t" + processRecipe(prefs, "recipe.ar.pattern",
				"runtime.ide.path", "${ARDUINO_IDE}",
				"compiler.ar.flags", "",
				"+compiler.ar.extra_flags", "${ARFLAGS}",
				"object_file", "$<", // /!\ without 's'
				"archive_file", "$*.a") + " $(wordlist 2,1000,$^)");
		// empty default ar flags and define new default ones
		out.println("ARFLAGS := rcs");

		out.println("\n## generate binary from .o files");
		out.println("${TARGET_DIR}/%.elf: ${OBJS}");
		// recipes contain a "{build.path}/{archive_file}" to include core lib, but it doesn't match our path constraints
		// => fake it by putting first object in it, and other ones in {object_files}
		// implies to deal with TARGET_DIR prefix since it's prepended to archive_file, but not to object_files
		out.println("\t" + processRecipe(prefs, "recipe.c.combine.pattern",
				"runtime.ide.path", "${ARDUINO_IDE}",
				"+compiler.c.elf.extra_flags", "${ELFFLAGS}",
				"object_files", "$(wordlist 2,1000,$^)", // /!\ with 's'
				"archive_file", "$(patsubst ${TARGET_DIR}/%,%,$(word 1,$^))") + " ${LDFLAGS}");
//		"object_files", "$(patsubst %,${TARGET_DIR}/%,$(wordlist 2,1000,$^))", // /!\ with 's'
//		"archive_file", "$<") + " ${LDFLAGS}");
		out.println("\n## with a dependency to a fake libEmpty.a since recipe needs it");
		out.println("${TARGET_DIR}/libEmpty.a:");
		out.println("\t> ${TARGET_DIR}/libEmpty.a:");

		out.println("\n## convert binary from .elf");
		out.println("${TARGET_DIR}/%.eep:${TARGET_DIR}/%.elf");
		out.println("\t" + processRecipe(prefs, "recipe.objcopy.eep.pattern",
				"runtime.ide.path", "${ARDUINO_IDE}",
				"+compiler.objcopy.eep.extra_flags", "${EEPFLAGS}",
				"build.project_name", "$*"));

		out.println("${TARGET_DIR}/%.hex:${TARGET_DIR}/%.elf");
		out.println("\t" + processRecipe(prefs, "recipe.objcopy.hex.pattern",
				"runtime.ide.path", "${ARDUINO_IDE}",
				"+compiler.elf2hex.extra_flags", "${HEXFLAGS}",
				"build.project_name", "$*"));

		// specific case : generate into a file then "cat" it, to keep a %-like rule
		out.println("${TARGET_DIR}/%.size:${TARGET_DIR}/%.elf");
		out.println("\t" + processRecipe(prefs, "recipe.size.pattern",
				"runtime.ide.path", "${ARDUINO_IDE}",
//				"+compiler.size.cmd", "${SIZEFLAGS}",
				"build.project_name", "$*") + " > $@");
		out.println("\tcat $@");

		out.println("\n## entry point for core compilation");
		out.println("HARDWARE_DIR := " + changeRoot(prefs, "runtime.hardware.path", "runtime.ide.path", "${ARDUINO_IDE}"));
		out.println("CORE_DIR := " + changeRoot(prefs, "build.core.path", "runtime.ide.path", "${ARDUINO_IDE}"));
		out.println("VARIANT_DIR := " + changeRoot(prefs, "build.variant.path", "runtime.ide.path", "${ARDUINO_IDE}"));
		out.println("INCLUDE_FLAGS := -I${CORE_DIR} -I${VARIANT_DIR}");

		out.println("\n## end of file");

		out.close();
	}

	/**
	 * change start of given path in another value (ie variable value)
	 * @param path path to modify
	 * @param reference preference name into which prefix path can be found
	 * @param newRef new value for this prefix
	 * @return modified path
	 */
	static String changeRoot(PreferencesMap prefs, String path, String reference, String newRef) {
		String pathValue = prefs.get(path);
		String refValue = prefs.get(reference);
		return pathValue.replace(refValue, newRef);
	}

	/**
	 * translate template string according to preferences and optional arguments 
	 * @param prefs preferences map containing strings templates to replace with
	 * @param recipeName name of template to get from preferences
	 * @param arguments list of successive key / value pairs specifying specific entry to add in map
	 * if a key starts with character '+', value is appended to existing map entry if exists, else it replaces its value
	 * @return translated string
	 * @throws Exception 
	 */
	static String processRecipe(PreferencesMap prefs, String recipeName, String... arguments) {
	    PreferencesMap dict = new PreferencesMap(prefs);
	    for(int i = 0; i < arguments.length; i += 2) {
	    	String key = arguments[i];
	    	String value = arguments[i + 1];
	    	if (key.charAt(0) == '+') {
	    		key = key.substring(1);
		    	if (dict.containsKey(key)) {
		    		value = dict.get(key) + " " + value;
		    	}
	    	}
	    	dict.put(key, value);
	    }

	    try {
	    	String recipe = prefs.getOrExcept(recipeName);
	    	String result, source = recipe;
	    	int retries = 10;
	    	result = StringReplacer.replaceFromMapping(recipe, dict);
	    	while (retries != 0 && !source.equals(result)) {
	    		source = result;
	    		result = StringReplacer.replaceFromMapping(source, dict);
	    		retries--;
	    	}
	    	return result;
		} catch (Exception e) {
//				throw new Exception(e);
			logger.error("Couldn't process recipe " + recipeName, e);
		}
	    return null;
	}

	protected static void usage(int exitCode) {
		HelpFormatter fmt = new HelpFormatter();
		String footer =
				"\narduino ide path is looked for respectivly in command line option, java properties (-DARDUINO_IDE=...)," +
				" ARDUINO_IDE environment variable, location of BaseNoGui arduino class if already loaded" +
				" (if classpath was set accordingly for example)";
		fmt.printHelp(80, "java -jar ArduinoMakeMake.jar options ...", "options :", options, footer);
		System.exit(exitCode);
	}
}
