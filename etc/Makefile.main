default: console

## little hack to avoid troubles with cygwin pathes
ifeq ($(findstring CYGWIN,$(shell uname)),)
  cygpath ?= ${1}
else
  cygpath = $(shell cygpath -m -w ${1})
endif

## MAKEFILE_LIST n-1'th item is caller Makefile => deduce caller project dir
##CALLER_DIR := $(call cygpath,$(dir $(realpath $(lastword $(filter-out $(lastword ${MAKEFILE_LIST}),${MAKEFILE_LIST})))))
CALLER_DIR := $(dir $(lastword $(filter-out $(lastword ${MAKEFILE_LIST}),${MAKEFILE_LIST})))

# must define those variables with = instead of :=, and before Makefile.common inclusion
# => when Makefile.common include in turn target/../Makefile, ${OBJS} (used as a prerequisite) will be defined.
C_SOURCES = $(call rwildcard,${CALLER_DIR},*.c)
CPP_SOURCES = $(call rwildcard,${CALLER_DIR},*.cpp)
INO_SOURCES = $(call rwildcard,${CALLER_DIR},*.ino)
OBJS = ${C_SOURCES:${CALLER_DIR}%.c=${TARGET_DIR}/%.o} ${CPP_SOURCES:${CALLER_DIR}%.cpp=${TARGET_DIR}/%.o} ${INO_SOURCES:${CALLER_DIR}%.ino=${TARGET_DIR}/%.o}


MAKE_MAKE_DIR := $(dir $(lastword ${MAKEFILE_LIST}))/../
include ${MAKE_MAKE_DIR}/etc/Makefile.common

## PROJECT_NAME may be already defined, else, use project dirname
PROJECT_NAME ?= $(notdir $(realpath ${CALLER_DIR}))

## deduce in and out file names
ifeq (${TODO},lib)
  OUT_NAME ?= lib${PROJECT_NAME}.a
else
  MAIN_SOURCE ?= $(wildcard ${CALLER_DIR}/${PROJECT_NAME}.ino ${CALLER_DIR}/${PROJECT_NAME}.cpp ${CALLER_DIR}/${PROJECT_NAME}.c \
		${CALLER_DIR}/main.ino ${CALLER_DIR}/main.cpp ${CALLER_DIR}/main.c)

  ifeq (${MAIN_SOURCE},)
    $(error Can't find main destination file. Caller must specify which one to use (MAIN_SOURCE=...))
  endif
  ifneq ($(words ${MAIN_SOURCE}),1)
    $(error Several files may be destination. Caller must specify which one to use (MAIN_SOURCE=...))
  endif

  OUT_NAME ?= $(notdir $(basename ${MAIN_SOURCE})).hex
endif

OUT_PATH := ${TARGET_DIR}/${OUT_NAME}
$(info MAIN_SOURCE=${MAIN_SOURCE})
$(info OUT_PATH=${OUT_PATH})
$(info INCLUDE_FLAGS=${INCLUDE_FLAGS})

LDFLAGS := ${LDFLAGS} -L${CORE_LIB_DIR} -lCore

bin: ${OUT_PATH} ${OUT_PATH:%.hex=%.size} | ${TARGET_DIR}
lib: ${OUT_PATH} | ${TARGET_DIR}

# try to launch upload only if binary got compiled again
DO_UPLOAD=""
console: consoleFlag
	${ARD_CONSOLE} -b ${TARGET_BOARD} -p ${UPLOAD_PORT} -f ${OUT_PATH} ${DO_UPLOAD}

consoleFlag: ${OUT_PATH}
	touch consoleFlag
	$(eval DO_UPLOAD="-u")

# always launch upload, even if binary didn't get compiled
upload: ${OUT_PATH}
	${ARD_CONSOLE} -b ${TARGET_BOARD} -p ${UPLOAD_PORT} -f ${OUT_PATH} -u -x

${OUT_PATH}: ${CORE_LIB} ${DEPENDENCIES}

${CORE_LIB}:
	${MAKE} -C ${MAKE_MAKE_DIR} -f etc/Makefile.core

.PHONY: bin lib dependencies corelib upload console
